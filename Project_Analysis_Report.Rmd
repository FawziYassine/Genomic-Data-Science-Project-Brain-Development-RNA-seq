---
title: 'Genomic Data Science Final Project: Analysis Report'
date: "Last updated:`r format(Sys.time(), '%d/%m/%y')`"
output:
  html_document:
    toc: yes
    df_print: paged
---

# 1. Getting the Data

## 1.1. Downloading the Reads

The reads were obtained from SRA in the form of a set of FASTQ files. The FASTQ files were downloaded using **sratoolkit.2.9.6**. The following Bash script was employed:

```{bash eval=FALSE}
#!/bin/bash

# FETAL SAMPLES

fastq-dump -v --gzip --split-files -O /data/sra  SRR2071348
printf “\n****** SRR2071348 is downloaded  ...\n\n”

fastq-dump -v --gzip --split-files -O /data/sra  SRR2071349
printf “\n****** SRR2071349 is downloaded  ...\n\n”

fastq-dump -v --gzip --split-files -O /data/sra  SRR2071352
printf “\n****** SRR2071352 is downloaded  ...\n\n”

# ADULT SAMPLES

fastq-dump -v --gzip --split-files -O /data/sra  SRR2071346
printf “\n****** SRR2071346 is downloaded  ...\n\n”

fastq-dump -v --gzip --split-files -O /data/sra  SRR2071347
printf “\n****** SRR2071347 is downloaded  ...\n\n”

fastq-dump -v --gzip --split-files -O /data/sra SRR2071350
printf “\n****** SRR2071350 is downloaded  ...\n\n”
```

After saving the above script as *download-sra-reads.sh* in *bash-scripts* directory, the following Bash command was used for running it:

```{bash eval=FALSE}
nohup sh bash-scripts/download-sra-reads.sh > download-sra-reads.out &
```

## 1.2. Reads Quality Control

The quality of the reads was checked using **FastQC-v0.11.8**. The following Bash script was employed:

```{bash eval=FALSE}
#!/bin/bash
# ALL SAMPLES
fastqc -o fastqc /data/sra/*fastq.gz
```

## 1.3. Retrieving the Phenotype Data

The phenotype data of the samples was retrieved from the SRA website and stored in the *phenotype_data.tsv* file.

# 2. Reads Alignment

The FASTQ files were aligned (mapped) to the reference genome hg38 using **hisat2-2.1.0**.  The following Bash script was employed:

```{bash eval=FALSE}
#!/bin/bash

# FETAL SAMPLES

echo "Aligning the reads of run SRR2071348"
hisat2 -p 8 --dta -x /data/grch38/genome -1 /data/sra/SRR2071348_1.fastq.gz -2 /data/sra/SRR2071348_2.fastq.gz \
		| samtools sort -@ 8 -n -o /data/align/SRR2071348.bam
echo "Finished the aignment of reads of run SRR2071348"

echo "Aligning the reads of run SRR2071349"
hisat2 -p 8  --dta -x /data/grch38/genome -1 /data/sra/SRR2071349_1.fastq.gz -2 /data/sra/SRR2071349_2.fastq.gz \
		| samtools sort -@ 8 -n -o /data/align/SRR2071349.bam
echo "Finished the aignment of reads of run SRR2071349"

echo "Aligning the reads of run SRR2071352"
hisat2 -p 8  --dta -x /data/grch38/genome -1 /data/sra/SRR2071352_1.fastq.gz -2 /data/sra/SRR2071352_2.fastq.gz \
		| samtools sort -@ 8 -n -o /data/align/SRR2071352.bam
echo "Finished the aignment of reads of run SRR2071352"

# ADULT SAMPLES

echo "Aligning the reads of run SRR2071346"
hisat2 -p 8  --dta -x /data/grch38/genome -1 /data/sra/SRR2071346_1.fastq.gz -2 /data/sra/SRR2071346_2.fastq.gz \
		| samtools sort -@ 8 -n -o /data/align/SRR2071346.bam
echo "Finished the aignment of reads of run SRR2071346"

echo "Aligning the reads of r SRR2071347"
hisat2 -p 8  --dta -x /data/grch38/genome -1 /data/sra/SRR2071347_1.fastq.gz -2 /data/sra/SRR2071347_2.fastq.gz \
		| samtools sort -@ 8 -n -o /data/align/SRR2071347.bam
echo "Finished the aignment of reads of run SRR2071347"

echo "Aligning the reads of run SRR2071350"
hisat2 -p 8  --dta -x /data/grch38/genome -1 /data/sra/SRR2071350_1.fastq.gz -2 /data/sra/SRR2071350_2.fastq.gz \
		| samtools sort -@ 8 -n -o /data/align/SRR2071350.bam
echo "Finished the aignment of reads of run SRR2071350"
```

After saving the above script as *hisat2.sh* in *bash-scripts* directory, the following Bash command was used for running it:

```{bash eval=FALSE}
nohup sh bash-scripts/hisat2.sh > hisat2.out &
```

# 3. Counting Reads in Genes

## 3.1. Quantifying the Abundance of Genes
In order to quantify the abundance of genes in each sample, the number of reads corresponding to each gene in the genome in that sample is counted using **HTSeq.0.11.1**. The file *Homo_sapiens.GRCh38.103.gtf* provides hg38 genome annotations used in the counting. Gene annotations describe the structure of transcripts (model) expressed from those gene loci. A transcript model consists of the coordinates of the exons of a transcript on a reference genome. The following Bash script was employed:

```{bash eval=FALSE}
#!/bin/bash

ANNOT=/data/Homo_sapiens.GRCh38.103.gtf

# FETAL SAMPLES

printf "\nn***** Assembling the transcripts for run SRR2071348 ...\n\n" 
htseq-count -f bam -s no -m union --nonunique all -r name  /data/align/SRR2071348.bam $ANNOT > htseq/SRR2071348_counts.txt

printf "\nn***** Assembling the transcripts for run SRR2071349 ...\n\n" 
htseq-count -f bam -s no -m union --nonunique all -r name  /data/align/SRR2071349.bam $ANNOT > htseq/SRR2071349_counts.txt

printf "\nn***** Assembling the transcripts for run SRR2071352 ...\n\n" 
htseq-count -f bam -s no -m union --nonunique all -r name  /data/align/SRR2071352.bam $ANNOT > htseq/SRR2071352_counts.txt

# ADULT SAMPLES

printf "\nn***** Assembling the transcripts for run SRR2071346 ...\n\n" 
htseq-count -f bam -s no -m union --nonunique all -r name  /data/align/SRR2071346.bam $ANNOT > htseq/SRR2071346_counts.txt

printf "\nn***** Assembling the transcripts for run SRR2071347  ...\n\n" 
htseq-count -f bam -s no -m union --nonunique all -r name  /data/align/SRR2071347.bam $ANNOT > htseq/SRR2071347_counts.txt

printf "\nn***** Assembling the transcripts for run SRR2071350 ...\n\n" 
htseq-count -f bam -s no -m union --nonunique all -r name  /data/align/SRR2071350.bam $ANNOT > htseq/SRR2071350_counts.txt
```

After saving the above script as *htseq-count.sh* in *bash-scripts* directory, the following Bash command was used for running it:

```{bash eval=FALSE}
nohup sh bash-scripts/htseq-count.sh > htseq-count.out &
```

## 3.2. Merging the Count Files

The following R script was employed to merge the counts files into one file *merged_counts-v2.txt*:

```{r eval=FALSE}
# Set the working directory
setwd("~/brain/brain-zip/htseq-v2")

# Load fetal samples
SRX683795 <- read.table("SRR2071348_counts.txt", header = FALSE)
SRX683796 <- read.table("SRR2071349_counts.txt", header = FALSE)
SRX683799 <- read.table("SRR2071352_counts.txt", header = FALSE)

# Load adult samples
SRX683793 <- read.table("SRR2071346_counts.txt", header = FALSE)
SRX683794 <- read.table("SRR2071347_counts.txt", header = FALSE)
SRX683797 <- read.table("SRR2071350_counts.txt", header = FALSE)

# check to see if all elements of the first column (transcripts) are the same across all 6 samples
all(SRX683797[,1] == SRX683794[,1])
all(SRX683793[,1] == SRX683794[,1])
all(SRX683799[,1] == SRX683793[,1])
all(SRX683797[,1] == SRX683794[,1])
all(SRX683795[,1] == SRX683797[,1])

# create a merged_counts table
merged_counts <- data.frame(row.names = SRX683795[,1], SRX683795 = SRX683795[,2], SRX683796 = SRX683796[,2]
                            , SRX683799 = SRX683799[,2], SRX683793 = SRX683793[,2]
                            , SRX683794 = SRX683794[,2], SRX683797 = SRX683797[,2])
write.table(merged_counts, "../../merged_counts-v2.tsv", quote = FALSE, sep = '\t')
```

# 4. Exploratory Analysis

In this section, I explore the data (read counts) to get an idea of what the distribution of the data will look like.

## 4.1. Loading the Necessary Libraries and Data

```{r message=FALSE}
library(AnnotationDbi)
library(org.Hs.eg.db)
library(dplyr)
setwd("~/brain")
par(pch = 19) 
tropical = c("darkorange", "dodgerblue", "hotpink", "limegreen", "yellow")
palette(tropical)

# read a merged_counts file
merged_counts = read.table("merged_counts.tsv", quote = "", sep = '\t')
    
# Read phenotype sample data
pheno_data = read.csv("phenotype_data.tsv", quote = "", sep = '\t')
```

## 4.2. Checking the Phenotype Data

```{r}
table(pheno_data$sex)
sum(pheno_data$age_group == " ")
table(pheno_data$age_group, useNA = "ifany")
table(pheno_data$sex, pheno_data$age_group)
```

## 4.3. Normalization of Expression Data (Read Counts)

This is done here according to the Read Per Million (RPM) unit.

```{r}
x = as.matrix(merged_counts)
counts_RPM = t(t(x) * 1e6 / colSums(x))
dim(counts_RPM)
head(counts_RPM, 2)
```

## 4.4. Checking the Distribution of the Expression Data (Read Counts)

Here, are some checks of the distribution of the expression data (output not shown)

```{r eval=FALSE}
is.na(counts_RPM[1,])
sum(is.na(counts_RPM))

# Make the distribution of NA's by genes
gene_na = rowSums(is.na(counts_RPM))
gene_na[5]
gene_na[1:5]

# Make the distribution of NA's by samples
sample_na = colSums(is.na(counts_RPM))
sample_na[6]
table(sample_na)
```

## 4.5. Boxplot of Counts (Filtered and log2 Transformed) of All the Samples

```{r cache=FALSE}
counts_RPM = as.data.frame(counts_RPM)
fil_counts_RPM = filter(counts_RPM, rowMeans(counts_RPM) > 1)
dim(fil_counts_RPM)
boxplot(as.matrix(log2(fil_counts_RPM+1)), col=2, cex.axis = 0.8, cex.lab = 1.2, xlab = "samples", ylab = "log2(filtered_counts + 1)", main = "Boxplot of Counts (Filtered and log2 Transformed) of All the Samples")
```

## 4.6. Histogram of the Counts of the First Sample

Plot a histogram to show the probability/frequency distribution of the filtered counts data of the first sample.

```{r warning=FALSE}
hist(log2(fil_counts_RPM[,1]+1), col = 2, Xlab = "log2(filtered_counts[,1] + 1)", main = "Histogram of the Counts of the First Sample")
```

## 4.7. MA-plot Between the First 2 Samples

The MA-plot between the first 2 samples is used to visualize the differences between measurements in those samples.

```{r}
aa = log2(counts_RPM[,1]+1) + log2(counts_RPM[,2]+1)
mm = log2(counts_RPM[,1]+1) - log2(counts_RPM[,2]+1)
plot(aa, mm, col=2, main = "MA-plot Between the First 2 Samples")
```

## 4.8. Counts of Chromosome Y Genes in Male and Female Samples

Since cells of female samples lack Y chromosomes, we expect that male samples have more genes on this chromosome than female samples.

```{r warning=FALSE}
par(pch = 19)
rownames(counts_RPM) = sub("\\.\\d+$", "", rownames(counts_RPM))
chr = AnnotationDbi::select(org.Hs.eg.db, keys = rownames(counts_RPM), keytype = "ENSEMBL", columns = "CHR")
chr = chr[!duplicated(chr[,1]),]
# Confirm that the annotations still have the same sort as the counts
all(chr[,1] == rownames(counts_RPM))
## [1] TRUE
# Select the chromosome Y samples
fil_chrm_Y_counts_RPM = filter(counts_RPM, chr$CHR == "Y")
# Male samples have more genes on chromosome Y than females
pheno_data$sex = as.factor(pheno_data$sex)
boxplot(colSums(fil_chrm_Y_counts_RPM) ~ pheno_data$sex, col=2, main = "Boxplot: Counts of Chrom. Y Genes in Male and Female Samples")
points(colSums(fil_chrm_Y_counts_RPM) ~ jitter(as.numeric(pheno_data$sex)))
```

# 5. Differential Expression Analysis

Differential expression analysis between the sample age groups (adult vs. fetal) while adjusting for RIN was
performed using DESeq2_1.24.0.  
For a particular gene, a log2 fold change of -1 for **age_group** (adult vs. fetal) means that being an adult induces a multiplicative change in observed gene expression level of 2^−1=0.5 compared to the being a fetal. If the variable of interest is continuous-valued, then the reported log2 fold change is per unit of change of that variable.

## 5.1. Loading the Necessary Libraries

```{r message=FALSE}
library(SummarizedExperiment)
library(DESeq2)
library(ggplot2)
library(ggthemes)
```

## 5.2. Create DESeq2 Object and Get the Results (symbol annotated genes with FDR < 0.05)

```{r, message=FALSE,warning=FALSE}
deseq.dat = DESeqDataSetFromMatrix(countData = merged_counts, colData = pheno_data, design = ~ RIN + age_group)

# pre-filter
keep = rowSums(counts(deseq.dat)) >= 10 
deseq.dat = deseq.dat[keep,]

dds = DESeq(deseq.dat)
# DESeq2 results
res_deseq2 = results(dds, contrast = c("age_group", "adult", "fetal"))
res_deseq2_shrunk = lfcShrink(dds=dds, contrast = c("age_group", "adult", "fetal"), res = res_deseq2, type = "ashr")

# identify genes with FDR < 0.05
res_deseq2_shrunk_sig = subset(res_deseq2_shrunk, res_deseq2_shrunk$padj < 0.05)

# add gene symbol to res
gene_symbol = read.table("brain-zip/Ensembl.symbols.txt", header = TRUE, na.strings = "n/a", col.names = c("gene", "symbol"))
table(duplicated(gene_symbol$symbol))
gene_symbol = gene_symbol[!duplicated(gene_symbol$symbol), ]
res_deseq2_shrunk_sig = as.data.frame(res_deseq2_shrunk_sig)
res_deseq2_shrunk_sig$row = rownames(res_deseq2_shrunk_sig)
res_deseq2_shrunk_annotated = merge(res_deseq2_shrunk_sig, gene_symbol, by.x = "row", by.y = "gene")
dim(res_deseq2_shrunk_annotated)
# Sort by increasing log2FoldChange
sorted_significant_differ_res_deseq2_shrunk = res_deseq2_shrunk_annotated[sort.list(res_deseq2_shrunk_annotated$log2FoldChange, decreasing = TRUE),]
```

## 5.3. MA-plot between All the Samples
MA-plot between the sample age groups (adult vs. fetal) while adjusting for RIN: plot log2 fold-changes (on
the y-axis) versus the mean of normalized counts (on the x-axis).

```{r}
pval_threshold = 10e-3
plotMA(res_deseq2, alpha = pval_threshold, main = "MA-plot between All the Samples") 
```

## 5.4. Plot Counts

Plot the counts of the gene which had the smallest adjusted p value from the results table created above.
```{r}
par(pch = 19) 
minGene = which.min(res_deseq2_shrunk_annotated$padj)
plotCounts(dds, gene=minGene, intgroup="age_group", main = paste0("Counts of maximum p-value adjusted gene ", res_deseq2_shrunk_annotated[minGene, 7], " in all samples"), xlab = "age_group")
```

## 5.5. Heatmaps using pheatmap package (pretty heatmaps)

Heatmaps are a useful method to explore large multivariate data sets. Response variables (e.g., abundances) are visualised using colour gradients or colour schemes. With the right transformation, and row and column clustering, interesting patterns within the data can be seen. They can also be used to show the results after statistical analysis, for example, to show those variables that differ between treatment groups.

### 5.5.1. Heatmap of the Expressions

This heatmap gives us an overview over the similarities and dissimilarities between samples' expressions.  
For example, from the heatmap of the 20 highest gene expressions below we notice that the  **age_groupe** variable has an effect on the gene expression, where the *adult* group has higher expressions than the *fetal* group. Whereas, the **sex** variable has no noticeable effect. 

```{r warning=FALSE}
library("pheatmap")
select = order(rowMeans(counts(dds,normalized=TRUE)), decreasing=TRUE)[1:20]
df = as.data.frame(pheno_data[, c("age_group", "sex")])
rownames(df) = colnames(dds)
ntd = normTransform(dds)
pheatmap(assay(ntd)[select,], cluster_rows=FALSE, show_rownames=FALSE, cluster_cols=FALSE, annotation_col=df)
```

### 5.5.2. Heatmap of the sample-to-sample distances

```{r warning=FALSE}
vsd  = vst(dds, blind = FALSE)
sampleDists = dist(t(assay(vsd)))
library("RColorBrewer")
sampleDistMatrix <- as.matrix(sampleDists)
colors <- colorRampPalette( rev(brewer.pal(9, "Blues")) )(255)
pheatmap(sampleDistMatrix,
         clustering_distance_rows=sampleDists,
         clustering_distance_cols=sampleDists,
         col=colors)
```

## 5.6. Volcano Plot

Volcano Plots are used to visualize the significance and the magnitude of changes in genes. For example, from the plot below, we can notice that the MT1H (Metallothionein-1H gene, which is associated with autism) is upregulated (23 log2 fold-change) in the adult group vs. the fetal group. 

![Volcano Plot](plots/Volcano_Plot.png)
```{r eval=FALSE}
library(EnhancedVolcano)
EnhancedVolcano(sorted_significant_differ_res_deseq2_shrunk, FCcutoff = 1, pCutoff = pval_threshold,
                sorted_significant_differ_res_deseq2_shrunk$symbol,
                x = 'log2FoldChange', y = 'pvalue',
                legend = c("Non-significant", "Passed log2 fold-change threshold", "Passed the p-value threshold", "Passed both thresholds"),
                legendPosition = 'right',
                legendLabSize = 9,
                legendIconSize = 2,
                widthConnectors = 0.2,
                colConnectors = 'grey30',
                colAlpha = 1)
```

## 5.7. Principal Components Analysis (PCA) plot

A PCA plot shows clusters of samples based on their similarity. It reduces the overwhelming number of dimensions by constructing principal components (PCs).

```{r warning=FALSE}
rld = rlogTransformation(dds)
plotPCA(rld, intgroup = "age_group") + ggtitle("PCA Plot of the Expression Data") + theme_few()
```

# 6. Epigenetics and Expression Analysis
The following R script gets the percentage of overlap between the promoters of differentially expressed genes found in step 5. (Differential Expression Analysis) and the epigenetically marked (**H3K4me3**) promoters in the fetal and adult brains, and in liver cell lines.

```{r message=FALSE}
library(AnnotationHub)
library(TxDb.Hsapiens.UCSC.hg19.knownGene)
library(EnsDb.Hsapiens.v86)
```

## 6.1. Get the Promoter Associated Histone Modifications (**H3k4me3**) Narrow Peaks Data from Annotationhub (**EpigenomeRoadMap**)

```{r}
# initialize AnnotationHub object
ah = AnnotationHub()
ah = subset(ah, species == "Homo sapiens")
# get the narrow peaks data (promoter associated histone modification H3K4me3) for the fetal brain cells
fetal.brain = AnnotationHub::query(ah, c("EpigenomeRoadMap", "H3K4me3", "E081"))
fetal.brain.gr = fetal.brain[[2]]
# get the narrow peaks data (promoter associated histone modification H3K4me3) for the adult brain cells
adult.brain = AnnotationHub::query(ah, c("EpigenomeRoadMap", "H3K4me3", "E073"))
adult.brain.gr = adult.brain[[2]]
# get the narrow peak data (promoter associated histone modification H3K4me3) for liver cell line 
liver.line = AnnotationHub::query(ah, c("EpigenomeRoadMap", "H3K4me3", "Liver"))
liver.line.gr = liver.line[[2]]
```

## 6.2. Change **ENSEMBL ID** to **ENTREZID** that Matches gene_id in **TXDB**

```{r message=FALSE}
sorted_significant_differ_res_deseq2_shrunk$gene = sub("\\.\\d+$", "", as.character(sorted_significant_differ_res_deseq2_shrunk$row))
AnnotationDbi::keytypes(EnsDb.Hsapiens.v86)
sorted_significant_differ_res_deseq2_shrunk.map = AnnotationDbi::select(EnsDb.Hsapiens.v86, keys = as.character(sorted_significant_differ_res_deseq2_shrunk$gene), keytype = "GENEID", columns = "ENTREZID")
```

## 6.3. Get the Promoters of DGEs Found in Step 5

```{r message=FALSE}
# get the known genes from Tx database
txdb = TxDb.Hsapiens.UCSC.hg19.knownGene
txdb.genes = genes(txdb)
# get the promoters of differentially expressed genes
diff.expressed.gene.promoters = promoters(txdb.genes[txdb.genes$gene_id %in% sorted_significant_differ_res_deseq2_shrunk.map$ENTREZID,])
```

## 6.4. Calculate the Percentage of Overlap Between the Promoters of DEGs Found in Step 5 and the Epigenetically Marked (**H3K4me3**) Promoters in the 3 Different Kind of Cells

The percentage of overlap between the promoters of differentially expressed genes found in step 5. (Differential Expression Analysis) and the epigenetically marked (**H3K4me3**) promoters in the **fetal brain cells** is calculated as following:

```{r}
# subsetByOverlaps() extracts the elements in the query (the first argument) that overlap at least one element in the subject (the second argument).
fetal.brain.overlap.H3K4me3 = subsetByOverlaps(diff.expressed.gene.promoters, fetal.brain.gr)
(fetal.brain.overlap.percentage.H3K4me3 = length(fetal.brain.overlap.H3K4me3) / length(sorted_significant_differ_res_deseq2_shrunk.map$ENTREZID) * 100)
```

The percentage of overlap between the promoters of differentially expressed genes found in step 5. (Differential Expression Analysis) and the epigenetically marked (**H3K4me3**) promoters in the **adult brain cells** is calculated as following:

```{r}
# subsetByOverlaps() extracts the elements in the query (the first argument) that overlap at least one element in the subject (the second argument).
adult.brain.overlap.H3K4me3 = subsetByOverlaps(diff.expressed.gene.promoters, adult.brain.gr)
(adult.brain.overlap.percentage.H3K4me3 = length(adult.brain.overlap.H3K4me3) / length(sorted_significant_differ_res_deseq2_shrunk.map$ENTREZID) * 100)
```

The percentage of overlap between the promoters of differentially expressed genes found in step 5. (Differential Expression Analysis) and the epigenetically marked (**H3K4me3**) promoters in the **liver cell line** is
calculated as following:

```{r}
# subsetByOverlaps() extracts the elements in the query (the first argument) that overlap at least one element in the subject (the second argument).
liver.line.overlap.H3K4me3 = subsetByOverlaps(diff.expressed.gene.promoters, liver.line.gr)
(liver.line.overlap.percentage.H3K4me3 = length(liver.line.overlap.H3K4me3) / length(sorted_significant_differ_res_deseq2_shrunk.map$ENTREZID) * 100)
```
